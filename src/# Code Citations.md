# Code Citations

## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: Apache-2.0
https://github.com/Chiklet/chiklet/blob/f6abb641cea16258a233014d0af2cb785010e672/1

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dan
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: desconhecido
https://github.com/luiz158/socius/blob/cdcc245a3fe6e54931d20ac1299554b56a1e74a8/src/main/webapp/member-edit.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: 0BSD
https://github.com/agraluca/blog-gatsby/blob/a5b2ce73f01d912c0cc061b9a59dae5c80d8cb48/posts/2020-09-24-basico-ao-avancado-s01e06.md

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```


## License: desconhecido
https://github.com/4shx1/Yoho/blob/ba8f45ce293fa142f612968a75f6d5e91e73d8dc/index.html

```
Agora tenho uma visÃ£o completa de todos os arquivos. Preciso verificar quais ferramentas de ediÃ§Ã£o estÃ£o disponÃ­veis.NÃ£o tenho ferramentas de ediÃ§Ã£o de arquivos ou terminal habilitadas nesta sessÃ£o. Vou fornecer o cÃ³digo completo de todos os arquivos para que vocÃª possa criÃ¡-los. **Habilite as ferramentas de ediÃ§Ã£o e terminal** para que eu possa aplicar automaticamente, ou copie os arquivos abaixo.

---

## 1. [package.json](package.json) â€” Atualizado

```json
{
  "name": "adsanhanguera",
  "version": "2.0.0",
  "description": "Plataforma educacional ADS Anhanguera - Oficina de SoluÃ§Ãµes Profissionais",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dansfisica85/adsanhanguera.git"
  },
  "keywords": [],
  "author": "Davi Antonino Nunes da Silva",
  "license": "ISC",
  "type": "commonjs",
  "bugs": {
    "url": "https://github.com/dansfisica85/adsanhanguera/issues"
  },
  "homepage": "https://github.com/dansfisica85/adsanhanguera#readme",
  "dependencies": {
    "@libsql/client": "^0.17.0",
    "bcryptjs": "^2.4.3",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.2"
  }
}
```

---

## 2. [src/auth.js](src/auth.js) â€” Novo arquivo

```javascript
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const JWT_SECRET = process.env.JWT_SECRET || "ads-anhanguera-secret-2026";
const JWT_EXPIRES = "7d";

async function hashSenha(senha) {
  return bcrypt.hash(senha, 10);
}

async function verificarSenha(senha, hash) {
  return bcrypt.compare(senha, hash);
}

function gerarToken(usuario) {
  return jwt.sign(
    { id: usuario.id, email: usuario.email, role: usuario.role, nome: usuario.nome },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES }
  );
}

function verificarToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

function middlewareAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token de autenticaÃ§Ã£o nÃ£o fornecido." });
  }
  try {
    const token = authHeader.split(" ")[1];
    req.user = verificarToken(token);
    next();
  } catch (err) {
    return res.status(401).json({ error: "Token invÃ¡lido ou expirado." });
  }
}

function middlewareRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }
    next();
  };
}

module.exports = { hashSenha, verificarSenha, gerarToken, verificarToken, middlewareAuth, middlewareRole };
```

---

## 3. [src/database.js](src/database.js) â€” Reescrito

```javascript
const { createClient } = require("@libsql/client");
const { hashSenha } = require("./auth");
require("dotenv").config();

const db = createClient({
  url: process.env.TURSO_DATABASE_URL,
  authToken: process.env.TURSO_AUTH_TOKEN,
});

const USUARIOS_SEED = [
  { nome: "Davi Antonino Nunes da Silva", email: "professordavi85@gmail.com", senha: "Ads@Admin#", role: "admin" },
  { nome: "Coordenadora Priscila", email: "coordenadora", senha: "Coord@Priscila#", role: "coordenador" },
  { nome: "Allan Casanova", email: "allancasanova724@gmail.com", senha: "allancasanova724@Ads2026", role: "aluno" },
  { nome: "Vitor Muniz", email: "vitorlgmuniz@gmail.com", senha: "vitorlgmuniz@Ads2026", role: "aluno" },
  { nome: "Eduardo JordÃ£o", email: "eduardosarnejordao@gmail.com", senha: "eduardosarnejordao@Ads2026", role: "aluno" },
  { nome: "Daniel Gomes", email: "danielgom0928@outlook.com", senha: "danielgom0928@Ads2026", role: "aluno" },
  { nome: "Adrian Japa", email: "Adrian.japa90@icloud.com", senha: "Adrian.japa90@Ads2026", role: "aluno" },
  { nome: "Renan LourenÃ§o Pedrosa", email: "renanlourencopedrosa@gmail.com", senha: "renanlourencopedrosa@Ads2026", role: "aluno" },
];

async function initDB() {
  await db.batch([
    `CREATE TABLE IF NOT EXISTS usuarios (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      nome TEXT NOT NULL,
      email TEXT UNIQUE NOT NULL,
      senha_hash TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'aluno',
      criado_em TEXT DEFAULT (datetime('now'))
    )`,
    `CREATE TABLE IF NOT EXISTS respostas (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      aluno_id INTEGER NOT NULL,
      unidade INTEGER NOT NULL,
      etapa INTEGER NOT NULL,
      exercicio INTEGER NOT NULL,
      resposta TEXT NOT NULL,
      nota REAL DEFAULT 0,
      feedback TEXT DEFAULT '',
      tentativa INTEGER DEFAULT 1,
      enviado_em TEXT DEFAULT (datetime('now')),
      FOREIGN KEY (aluno_id) REFERENCES usuarios(id)
    )`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_aluno ON respostas(aluno_id)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_unidade ON respostas(unidade, etapa, exercicio)`,
    `CREATE INDEX IF NOT EXISTS idx_respostas_tentativa ON respostas(aluno_id, unidade, etapa, exercicio, tentativa)`,
  ]);

  // Seed de usuÃ¡rios
  for (const u of USUARIOS_SEED) {
    const existing = await db.execute({ sql: "SELECT id FROM usuarios WHERE email = ?", args: [u.email] });
    if (existing.rows.length === 0) {
      const hash = await hashSenha(u.senha);
      await db.execute({
        sql: "INSERT INTO usuarios (nome, email, senha_hash, role) VALUES (?, ?, ?, ?)",
        args: [u.nome, u.email, hash, u.role],
      });
      console.log(`  âœ… UsuÃ¡rio criado: ${u.email} (${u.role})`);
    }
  }

  console.log("âœ… Banco de dados inicializado com sucesso!");
}

module.exports = { db, initDB };
```

---

## 4. [server.js](server.js) â€” Reescrito

```javascript
const express = require("express");
const path = require("path");
require("dotenv").config();

const { db, initDB } = require("./src/database");
const gabaritos = require("./src/gabaritos");
const { avaliarResposta } = require("./src/avaliador");
const { verificarSenha, gerarToken, middlewareAuth, middlewareRole } = require("./src/auth");

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// ===== AUTH =====
app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, senha } = req.body;
    if (!email || !senha) return res.status(400).json({ error: "Email e senha sÃ£o obrigatÃ³rios." });

    const loginKey = email.trim().toLowerCase();
    const result = await db.execute({
      sql: "SELECT * FROM usuarios WHERE LOWER(email) = ?",
      args: [loginKey],
    });

    if (result.rows.length === 0) return res.status(401).json({ error: "UsuÃ¡rio nÃ£o encontrado." });

    const usuario = result.rows[0];
    const senhaOk = await verificarSenha(senha, usuario.senha_hash);
    if (!senhaOk) return res.status(401).json({ error: "Senha incorreta." });

    const token = gerarToken(usuario);
    res.json({
      token,
      usuario: { id: usuario.id, nome: usuario.nome, email: usuario.email, role: usuario.role },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro no login." });
  }
});

app.get("/api/auth/me", middlewareAuth, async (req, res) => {
  try {
    const result = await db.execute({ sql: "SELECT id, nome, email, role, criado_em FROM usuarios WHERE id = ?", args: [req.user.id] });
    if (result.rows.length === 0) return res.status(404).json({ error: "UsuÃ¡rio nÃ£o encontrado." });
    res.json({ usuario: result.rows[0] });
  } catch (err) {
    res.status(500).json({ error: "Erro ao buscar usuÃ¡rio." });
  }
});

// ===== RESPOSTAS (CRUD) =====
app.post("/api/respostas", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio, resposta } = req.body;
    const aluno_id = req.user.id;
    if (!unidade || !etapa || !exercicio || !resposta)
      return res.status(400).json({ error: "Todos os campos sÃ£o obrigatÃ³rios." });

    // Contar tentativas anteriores
    const tentativas = await db.execute({
      sql: "SELECT COUNT(*) as total FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ?",
      args: [aluno_id, unidade, etapa, exercicio],
    });
    const tentativa = (tentativas.rows[0].total || 0) + 1;

    const avaliacao = avaliarResposta(unidade, etapa, exercicio, resposta);

    await db.execute({
      sql: `INSERT INTO respostas (aluno_id, unidade, etapa, exercicio, resposta, nota, feedback, tentativa)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      args: [aluno_id, unidade, etapa, exercicio, resposta, avaliacao.nota, JSON.stringify(avaliacao), tentativa],
    });

    res.json({ avaliacao, tentativa });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao salvar resposta." });
  }
});

app.get("/api/respostas/:aluno_id", middlewareAuth, async (req, res) => {
  try {
    const { aluno_id } = req.params;
    // Alunos sÃ³ veem as prÃ³prias; admin/coord veem de qualquer um
    if (req.user.role === "aluno" && String(req.user.id) !== String(aluno_id)) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const { unidade } = req.query;
    let sql = "SELECT * FROM respostas WHERE aluno_id = ?";
    const args = [aluno_id];
    if (unidade) { sql += " AND unidade = ?"; args.push(unidade); }
    sql += " ORDER BY enviado_em DESC";

    const result = await db.execute({ sql, args });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.put("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const { resposta } = req.body;
    if (!resposta) return res.status(400).json({ error: "Resposta Ã© obrigatÃ³ria." });

    // Verificar dono
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    const avaliacao = avaliarResposta(resp.unidade, resp.etapa, resp.exercicio, resposta);
    await db.execute({
      sql: "UPDATE respostas SET resposta = ?, nota = ?, feedback = ?, enviado_em = datetime('now') WHERE id = ?",
      args: [resposta, avaliacao.nota, JSON.stringify(avaliacao), id],
    });

    res.json({ avaliacao });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao atualizar resposta." });
  }
});

app.delete("/api/respostas/:id", middlewareAuth, async (req, res) => {
  try {
    if (req.user.role === "coordenador") return res.status(403).json({ error: "Coordenador nÃ£o pode alterar dados." });

    const { id } = req.params;
    const existing = await db.execute({ sql: "SELECT * FROM respostas WHERE id = ?", args: [id] });
    if (existing.rows.length === 0) return res.status(404).json({ error: "Resposta nÃ£o encontrada." });

    const resp = existing.rows[0];
    if (req.user.role === "aluno" && resp.aluno_id !== req.user.id) {
      return res.status(403).json({ error: "Acesso nÃ£o autorizado." });
    }

    await db.execute({ sql: "DELETE FROM respostas WHERE id = ?", args: [id] });
    res.json({ message: "Resposta deletada com sucesso." });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao deletar resposta." });
  }
});

// ===== EXERCÃCIOS =====
app.get("/api/exercicios/:unidade", (req, res) => {
  const unidade = parseInt(req.params.unidade);
  const gab = gabaritos[unidade];
  if (!gab) return res.status(404).json({ error: "Unidade nÃ£o encontrada." });

  const exercicios = {};
  for (const [etapaKey, etapa] of Object.entries(gab.etapas)) {
    exercicios[etapaKey] = { titulo: etapa.titulo, exercicios: {} };
    for (const [exKey, ex] of Object.entries(etapa.exercicios)) {
      exercicios[etapaKey].exercicios[exKey] = { pergunta: ex.pergunta, conceitos: ex.conceitos };
    }
  }
  res.json({ titulo: gab.titulo, etapas: exercicios });
});

// ===== GABARITO (Condicional) =====
app.get("/api/gabarito/:unidade/:etapa/:exercicio", middlewareAuth, async (req, res) => {
  try {
    const { unidade, etapa, exercicio } = req.params;
    const gab = gabaritos[unidade]?.etapas?.[etapa]?.exercicios?.[exercicio];
    if (!gab) return res.status(404).json({ error: "Gabarito nÃ£o encontrado." });

    // Admin e coordenador sempre tÃªm acesso
    if (req.user.role === "admin" || req.user.role === "coordenador") {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    // Aluno: sÃ³ apÃ³s 3 tentativas com nota < 10
    const tentativas = await db.execute({
      sql: "SELECT nota FROM respostas WHERE aluno_id = ? AND unidade = ? AND etapa = ? AND exercicio = ? ORDER BY tentativa ASC",
      args: [req.user.id, unidade, etapa, exercicio],
    });

    const totalTentativas = tentativas.rows.length;
    const todasAbaixo10 = tentativas.rows.every(r => r.nota < 10);

    if (totalTentativas >= 3 && todasAbaixo10) {
      return res.json({ gabarito: gab.gabarito, palavrasChave: gab.palavrasChave });
    }

    return res.status(403).json({
      error: "Gabarito disponÃ­vel apÃ³s 3 tentativas com nota abaixo de 10.",
      tentativasAtuais: totalTentativas,
      faltam: Math.max(0, 3 - totalTentativas),
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar gabarito." });
  }
});

// ===== ADMIN / COORDENADOR =====
app.get("/api/admin/alunos", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const result = await db.execute(
      `SELECT u.id, u.nome, u.email, u.role, u.criado_em,
              COUNT(r.id) as total_respostas,
              COALESCE(AVG(r.nota), 0) as media_nota,
              MAX(r.enviado_em) as ultima_atividade
       FROM usuarios u
       LEFT JOIN respostas r ON u.id = r.aluno_id
       WHERE u.role = 'aluno'
       GROUP BY u.id
       ORDER BY u.nome`
    );
    res.json({ alunos: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao listar alunos." });
  }
});

app.get("/api/admin/alunos/:id/respostas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;
    const result = await db.execute({
      sql: "SELECT * FROM respostas WHERE aluno_id = ? ORDER BY unidade, etapa, exercicio, tentativa",
      args: [id],
    });
    res.json({ respostas: result.rows });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar respostas." });
  }
});

app.get("/api/admin/alunos/:id/evolucao", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const { id } = req.params;

    // Notas por tentativa/data
    const porData = await db.execute({
      sql: "SELECT nota, tentativa, unidade, etapa, exercicio, enviado_em FROM respostas WHERE aluno_id = ? ORDER BY enviado_em ASC",
      args: [id],
    });

    // MÃ©dia por unidade
    const porUnidade = await db.execute({
      sql: "SELECT unidade, AVG(nota) as media, COUNT(*) as total FROM respostas WHERE aluno_id = ? GROUP BY unidade ORDER BY unidade",
      args: [id],
    });

    // Info do aluno
    const aluno = await db.execute({ sql: "SELECT id, nome, email FROM usuarios WHERE id = ?", args: [id] });

    res.json({
      aluno: aluno.rows[0] || null,
      evolucao: porData.rows,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar evoluÃ§Ã£o." });
  }
});

app.get("/api/estatisticas", middlewareAuth, middlewareRole("admin", "coordenador"), async (req, res) => {
  try {
    const totalAlunos = await db.execute("SELECT COUNT(*) as total FROM usuarios WHERE role = 'aluno'");
    const totalRespostas = await db.execute("SELECT COUNT(*) as total FROM respostas");
    const mediaNotas = await db.execute("SELECT AVG(nota) as media FROM respostas");
    const porUnidade = await db.execute(
      "SELECT unidade, COUNT(*) as total, AVG(nota) as media FROM respostas GROUP BY unidade ORDER BY unidade"
    );
    res.json({
      totalAlunos: totalAlunos.rows[0].total,
      totalRespostas: totalRespostas.rows[0].total,
      mediaGeral: Math.round((mediaNotas.rows[0].media || 0) * 10) / 10,
      porUnidade: porUnidade.rows,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Erro ao buscar estatÃ­sticas." });
  }
});

// ===== DOCUMENTOS =====
app.get("/api/documentos", (req, res) => {
  const docs = {
    geral: [
      { nome: "Nutrientes Delivery - EstratÃ©gia e Arquitetura", arquivo: "/docs/geral/Nutrientes_Delivery.pdf", tipo: "pdf" },
      { nome: "Scrum - Valor em Mundos Complexos", arquivo: "/docs/geral/Scrum_Valor.pdf", tipo: "pdf" },
    ],
    u1: [
      { nome: "Aula 1 - InfogrÃ¡fico", arquivo: "/docs/u1/AULA_1.png", tipo: "imagem" },
      { nome: "U1 - Estudo de Caso", arquivo: "/docs/u1/U1_Estudo_de_Caso.pdf", tipo: "pdf" },
    ],
    u2: [
      { nome: "Aula 2 - InfogrÃ¡fico", arquivo: "/docs/u2/AULA_2.png", tipo: "imagem" },
      { nome: "U2 - ResoluÃ§Ã£o de Problemas", arquivo: "/docs/u2/U2_Resolucao.pdf", tipo: "pdf" },
    ],
    u3: [
      { nome: "Aula 3 - InfogrÃ¡fico", arquivo: "/docs/u3/AULA_3.png", tipo: "imagem" },
    ],
    u4: [
      { nome: "Aula 4 - InfogrÃ¡fico", arquivo: "/docs/u4/AULA_4.png", tipo: "imagem" },
      { nome: "U4 - Aprendizagem entre Pares", arquivo: "/docs/u4/U4_Aprendizagem.pdf", tipo: "pdf" },
    ],
  };
  res.json(docs);
});

// Proteger gabaritos PDF
app.get("/docs/gabaritos/:filename", middlewareAuth, async (req, res) => {
  if (req.user.role === "admin" || req.user.role === "coordenador") {
    return res.sendFile(path.join(__dirname, "docs_gabaritos", req.params.filename));
  }
  return res.status(403).json({ error: "Acesso restrito." });
});

// SPA fallback
app.get("/{*splat}", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
});

// Start
async function start() {
  await initDB();
  app.listen(PORT, () => {
    console.log(`ðŸš€ Servidor rodando em http://localhost:${PORT}`);
  });
}

start();
```

---

## 5. [public/index.html](public/index.html) â€” Reescrito completo

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ADS Anhanguera â€“ Projeto de Software</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

  <!--
```

